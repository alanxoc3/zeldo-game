#!/usr/bin/perl

use warnings;
use strict;
use experimental 'smartmatch';

# lua keywords
my @lua_keywords = qw(
break do else elseif end false for function goto if in local nil not or repeat
return then true until while and n b0d0 P_TEXT_LOGIC
);

my @pico8_api = qw(
_init _update _update60 _draw setmetatable getmetatable cocreate coresume
costatus yield load save folder ls run resume reboot stat info flip printh clip
pget pset sget sset fget fset print cursor color ceil cls camera circ circfill
line rect rectfill pal palt spr sspr add del all foreach pairs btn btnp sfx
music mget mset map peek poke memcpy reload cstore memset max min mid flr cos
sin atan2 sqrt abs rnd srand band bor bxor bnot shl shr cartdata dget dset sub
sgn stop menuitem type tostr tonum extcmd ls fillp time assert t
_update_buttons count mapdraw self ? __index rotl
);

# Order of commonly used letters in the English language.
# Saves *about* 30 compression tokens.
my $char_inc = "etaoinsrhldcumfpgwybvkxjqz";

my @cur_char_arr;
sub get_next_var_name {
   my @new_char_arr;
   my $next_bump = 1;
   foreach (reverse(@cur_char_arr)) {
      my $char_ind = (index($char_inc, $_)+$next_bump) % length($char_inc);
      push(@new_char_arr, substr($char_inc, $char_ind, 1));
      $next_bump = ($next_bump == 1 and $char_ind == 0) ? 1 : 0;
   }

   if ($next_bump == 1) {
      push(@new_char_arr, 'a');
   }

   @cur_char_arr = reverse(@new_char_arr);
   my $ret = join("", @cur_char_arr);
   if ($ret ~~ @pico8_api or $ret ~~ @lua_keywords) {
      return get_next_var_name();
   } else {
      return join("", @cur_char_arr);
   }
}

sub remove_spaces {
   my @new_lines;

   for (@_) {
      my $line = $_;
      $line =~ s/^\s+|\s+$//g;
      $line =~ s/ +/ /g;
      $line =~ s/" and/"and/g;
      $line =~ s/" or/"or/g;
      $line =~ s/" then/"then/g;
      # get rid of spaces between symbols.
      $line =~ s/\s?([\%\!\/\-\*\+\=\<\>\{\}\(\)\[\]\,\.])\s?/$1/g;
      if (length($line) > 0) {
         push @new_lines, $line;
      }
   }

   return @new_lines;
}

sub remove_comments {
   my @new_lines;

   for (@_) {
      my $line = $_;

      my @matches = ($line =~ /--.*/g);
      foreach(@matches) { $line =~ s/\Q$_\E//g; }

      if (length($line) > 0) {
         push @new_lines, $line;
      }
   }

   return @new_lines;
}

my @texts;
sub text_logic {
   my $non_quote = shift;
   my $quote = shift;
   $quote =~ tr/A-Za-z/a-zA-Z/; # flip the pico upper and lower case.
   push @texts, $quote;
   return $non_quote."P_TEXT_LOGIC";
}

# Removes tbox texts, similar to removing comments. ($|, "|)
sub remove_texts {
   my @new_lines;

   for (@_) {
      my $line = $_;
      $line =~ s/([^"]*)(\"[^\"]*\")/text_logic($1,$2)/ge;
      push @new_lines, $line;
   }

   return @new_lines
}

# Consistent quotes in project. Gun_vals assumes double quotes too.
sub single_quotes_to_double {
   my @new_lines;

   for (@_) {
      my $line = $_;
      $line =~ s/\'/\"/g;
      push @new_lines, $line;
   }

   return @new_lines
}

sub populate_vars {
   # tokenize based on most used tokens.
   # this saves about 100 compression tokens.
   my %vars;
   for (@_) {
      my $line = $_;
      my @matches = ($line =~ /[\W]*\b([a-z_]\w*)/g);
      foreach(@matches) {
         if (not ($_ ~~ @pico8_api or $_ ~~ @lua_keywords)) {
            if (not exists($vars{$_})) {
               $vars{$_} = 0;
            } else {
               $vars{$_}++;
            }
         }
      }
   }

   # assign most used tokens to correct variables.
   foreach my $name (reverse sort { $vars{$a} <=> $vars{$b} } keys %vars) {
      # print STDERR "$vars{$name}: $name\n";
      $vars{$name} = get_next_var_name();
   }

   return %vars;
}

my @lines = <>;
chomp(@lines);
@lines = remove_comments(@lines);
@lines = remove_texts(@lines);
@lines = single_quotes_to_double(@lines);
my %vars = populate_vars(@lines);

sub test_eval {
   my $punc = shift;
   my $var = shift;

   if (not ($var ~~ @pico8_api or $var ~~ @lua_keywords)) {
      if (exists($vars{$var})) {
         $var = $vars{$var};
      }
   }

   return "$punc$var";
}

sub pop_text {
   my $thing = shift;
   my $item = shift @texts;
   return $item;
}

sub tokenize_lines {
   my @new_lines;

   for (@_) {
      my $line = $_;
      $line =~ s/([\W]*\b)([a-z_]\w*)/test_eval($1,$2)/ge;
      push @new_lines, $line;
   }

   return @new_lines
}

sub pop_text_logics {
   my @new_lines;

   for (@_) {
      my $line = $_;
      $line =~ s/(P_TEXT_LOGIC)/pop_text($1)/ge;
      push @new_lines, $line;
   }

   return @new_lines
}

@lines = remove_spaces(@lines);
my $file_line = join(" ",@lines);
@lines = ($file_line);
@lines = remove_spaces(@lines);
@lines = tokenize_lines(@lines);

# Uncomment for each thing to go on its own line.
# Note that this is slightly more compression space.
# $lines[0] =~ s/([^\"]) ([^\"])/$1\n$2/g;
@lines = pop_text_logics(@lines);
print "$_" for @lines;
