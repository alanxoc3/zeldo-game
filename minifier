#!/usr/bin/perl

# lowercase()

use warnings;
use strict;
use experimental 'smartmatch';

# lua keywords
my @lua_keywords = qw(
break do else elseif end false for function goto if in local nil not or repeat
return then true until while and n b0d0 P_TEXT_LOGIC
);

my @pico8_api = qw(
_init _update _update60 _draw setmetatable getmetatable cocreate coresume
costatus yield load save folder ls run resume reboot stat info flip printh clip
pget pset sget sset fget fset print cursor color cls camera circ circfill line
rect rectfill pal palt spr sspr add del all foreach pairs btn btnp sfx music
mget mset map peek poke memcpy reload cstore memset max min mid flr cos sin
atan2 sqrt abs rnd srand band bor bxor bnot shl shr cartdata dget dset sub sgn
stop menuitem type tostr tonum extcmd ls fillp time assert t _update_buttons
count mapdraw self ? __index rotl
);

my $char_inc = "abcdefghijklmnopqrstuvwxyz";

my @cur_char_arr;
sub get_next_var_name { 
   my @new_char_arr;
   my $next_bump = 1;
   foreach (reverse(@cur_char_arr)) {
      my $char_ind = (index($char_inc, $_)+$next_bump) % length($char_inc);
      push(@new_char_arr, substr($char_inc, $char_ind, 1));
      $next_bump = ($next_bump == 1 and $char_ind == 0) ? 1 : 0;
   }

   if ($next_bump == 1) {
      push(@new_char_arr, 'a');
   }
   
   @cur_char_arr = reverse(@new_char_arr);
   my $ret = join("", @cur_char_arr);
   if ($ret ~~ @pico8_api or $ret ~~ @lua_keywords) {
      return get_next_var_name();
   } else {
      return join("", @cur_char_arr);
   }
}

sub remove_spaces {
   my @new_lines;

   for (@_) {
      my $line = $_;
      $line =~ s/^\s+|\s+$//g;
      $line =~ s/ +/ /g;
      $line =~ s/" and/"and/g;
      $line =~ s/" or/"or/g;
      $line =~ s/" then/"then/g;
      # get rid of spaces between symbols.
      $line =~ s/\s?([\%\!\/\-\*\+\=\<\>\{\}\(\)\[\]\,\.])\s?/$1/g;
      if (length($line) > 0) {
         push @new_lines, $line;
      }
   }

   return @new_lines;
}

sub remove_comments {
   my @new_lines;

   for (@_) {
      my $line = $_;

      my @matches = ($line =~ /--.*/g);
      foreach(@matches) { $line =~ s/\Q$_\E//g; }

      if (length($line) > 0) {
         push @new_lines, $line;
      }
   }

   return @new_lines;
}

my @texts;
sub text_logic {
   my $non_quote = shift;
   my $quote = shift;
   push @texts, $quote;
   return $non_quote."P_TEXT_LOGIC";
}

# Removes tbox texts, similar to removing comments. ($|, "|)
sub remove_texts {
   my @new_lines;

   for (@_) {
      my $line = $_;
      $line =~ s/([^"]*)(\"\|[^"]*\")/text_logic($1,$2)/ge;
      push @new_lines, $line;
   }

   return @new_lines
}

sub populate_vars {
   my %vars;
   for (@_) {
      my $line = $_;
      my @matches = ($line =~ /[\W]*\b([a-z_]\w*)/g);
      foreach(@matches) {
         if (not ($_ ~~ @pico8_api or $_ ~~ @lua_keywords)) {
            if (not exists($vars{$_})) {
               $vars{$_} = get_next_var_name();
            }
         }
      }
   }
   return %vars;
}

my @lines = <>;
chomp(@lines);
@lines = remove_comments(@lines);
@lines = remove_texts(@lines);
my %vars = populate_vars(@lines);

sub test_eval {
   my $punc = shift;
   my $var = shift;

   if (not ($var ~~ @pico8_api or $var ~~ @lua_keywords)) {
      if (exists($vars{$var})) {
         $var = $vars{$var};
      }
   }

   return "$punc$var";
}

sub pop_text {
   my $thing = shift;
   my $item = shift @texts;
   return $item;
}

sub tokenize_lines {
   my @new_lines;

   for (@_) {
      my $line = $_;
      $line =~ s/([\W]*\b)([a-z_]\w*)/test_eval($1,$2)/ge;
      push @new_lines, $line;
   }

   return @new_lines
}

sub pop_text_logics {
   my @new_lines;

   for (@_) {
      my $line = $_;
      $line =~ s/(P_TEXT_LOGIC)/pop_text($1)/ge;
      push @new_lines, $line;
   }

   return @new_lines
}

@lines = remove_spaces(@lines);
my $file_line = join(" ",@lines);
@lines = ($file_line);
@lines = remove_spaces(@lines);
@lines = tokenize_lines(@lines);

# Uncomment for each thing to go on its own line.
# Note that this is slightly more compression space.
# $lines[0] =~ s/([^\"]) ([^\"])/$1\n$2/g;
@lines = pop_text_logics(@lines);
print "$_" for @lines;
